<!doctype html>
<html>

<head>
    <style>
        /*Element with id="container" will follow the regular positioning flow of the html document*/
        #container {
            position: relative;
        }

        /*Within an element with id="container", elements with id="canvas" will have an absolute position
              Elements with id="overlay" (in general) will have an absolute position
              Absolute position is unaffected by rest of the html doc
              This allows for the generation of our grid of buttons on top of a canvas element*/
        #container canvas,
        #overlay {
            position: absolute;
        }

        canvas {
            border: 1px solid black;
        }

        .categories-buttons {
            /*grid of 10 columns, each being 70 pixels wide*/
            display: grid;
            grid-template-columns: 70px 70px 70px 70px 70px 70px 70px 70px 70px 70px;
        }

        /*Style of Individual buttons*/
        .tile-style {
            height: 50px;
            font-weight: bold;
            font-size: 20px;
        }
    </style>
</head>

<body>
    <h1>MINESWEEPER</h1>
    <!--Pre-Game start-up menu/info-->
    <button id="start_game_button">Start Game</button>
    <br><br>
    <label for="mineCount">Mines:</label>
    <select id="mineCount">
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15" selected>15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20</option>
    </select>
    <p id="start_info">Select number of mines and click Start Game to begin!</p>
    <p id="flagCounter"></p>

    <!--Create the canvas and overlay-->
    <div id="container">
        <canvas id="canvas" width="700" height="500"></canvas>
        <div id="overlay" class="categories-buttons"></div>
    </div>
    <script>

        let NUM_MINES; // change this to the result of the input form
        let flag_count; // equal to number of mines to start
        let revealed_count; // number of revealed tiles
        const minefield = new Array(100); // moving to global scope so other functions can reference this easily
        let mouse_x = 0;
        let mouse_y = 0;
        let game_in_progress = false;
        let board_initialized = false;

        //get access to the start game button
        var start_game_button = document.getElementById("start_game_button");

        // HTML to track flags for user
        let flag_counter = document.getElementById("flagCounter");

        //when the start button is clicked, chosen settings will be applied
        start_game_button.addEventListener("click", apply_settings);

        //get access to the divider and the canvas elements
        var div = document.getElementsByClassName("categories-buttons")[0];
        const context = document.getElementById("canvas").getContext("2d");

        function generate_game_grid() {
            div.innerHTML = ""; // clear the div. Be careful about this when adding the labels!!

            //for a 10x10 grid, we will have 100 buttons
            for (var i = 0; i < 100; i++) {

                //create a button element and store it in a tempButton variable
                var tempButton = document.createElement("button");

                //give the tempButton an id (will be converted to a string)
                tempButton.id = i;

                // give the button a flag to tell if it is flagged or not
                tempButton.is_flagged = 0;

                //make the height of the button be 50px (1/10 * height of the canvas)
                tempButton.className = "tile-style";

                // add left-click event handler to the button
                tempButton.addEventListener("click", left_click);

                // f-key event listener needs to know whether or not mouse is hovering over
                // button.
                tempButton.is_hovering = false;
                tempButton.addEventListener("mouseenter", function () {
                    this.is_hovering = true;
                });
                tempButton.addEventListener("mouseleave", function () {
                    this.is_hovering = false;
                });

                //append the tempButton to the element that div is "pointing" to
                div.append(tempButton);
            }
        }
            // track mouse's coordinates for flagging spaces
            document.addEventListener("mousemove", function () {
                mouse_x = event.clientX;
                mouse_y = event.clientY;
            });
            // event listener for f-key/flagging
            document.addEventListener("keydown", function (event) {
                console.log('f clicked.', game_in_progress );
                
                if (!game_in_progress) {
                    return; // do nothing if game is not active
                }
                let button = document.elementFromPoint(mouse_x, mouse_y);
                if (button.is_hovering && event.key === "f") {
                    console.log('flag key:', !button.is_flagged, !button.disabled, flag_count > 0);
                    if (!button.is_flagged && !button.disabled && flag_count > 0) { // flag
                        console.log('flagging now');
                        flag_count--;
                        button.innerHTML = "FLAG";
                        button.style.color = "#008CBA";
                        flag_counter.innerText = `${flag_count} flags left`;

                        button.is_flagged = !button.is_flagged;
                    } else if (button.is_flagged && !button.disabled) { // unflag
                        flag_count++;
                        button.innerHTML = "";
                        flag_counter.innerText = `${flag_count} flags left`;

                        button.is_flagged = !button.is_flagged;
                    }
                }
            });
        
        
        function apply_settings() {

            if (game_in_progress == false) {
                //TODO: add extra settings if implemented in future
                NUM_MINES = document.getElementById("mineCount").value;
                flag_count = NUM_MINES;
                revealed_count = 0;

                //get the settings paragraph
                var start_info = document.getElementById("start_info");
                
                //change the text to show settings to validate that they've been applied
                console.log(`Game started with ${NUM_MINES} mines`);
                start_info.innerText = "Status: Playing";
                flag_counter.innerText = `${flag_count} flags left`;
                document.getElementById("start_game_button").innerText = "Game Started!";


                generate_game_grid();
                game_in_progress = true;

            } else {

                alert("Game Is In Progress!")

            }

        }

        function left_click() {
            // "this" refers to the HTML element that called this function
            console.log(this.id);
            const id = parseInt(this.id);

            // ignore if game is not active
            if (!game_in_progress) {
                return;
            }

            // generate the mine positions only after the first click
            if (!board_initialized) {
                board_initialized = 1;
                generate_array(NUM_MINES, id);
            }

            // we can disable buttons once their number is revealed, so this is all we need to check
            if (!this.is_flagged) {
                if (minefield[id] == "*") {
                    gameOver();
                }
                reveal(this);
            }

            // check for victory
            console.log('checking for victory:', revealed_count, 100 - NUM_MINES);
            if (revealed_count == 100 - NUM_MINES) {
                game_in_progress = false;
                board_initialized = false;
                document.getElementById("start_game_button").innerText = "New Game?";
                document.getElementById("start_info").innerText = "Game Over: Victory!";
            }
            
        }

        function gameOver() {
            console.log("You lose :(");
            game_in_progress = false;
            board_initialized = false;
            document.getElementById("start_game_button").innerText = "New Game?";
            document.getElementById("start_info").innerText = "Game Over: Defeat";
            // reveal all bombs
            for (let i = 0; i < 100; i++) {
                if (minefield[i] == '*') {
                    reveal(document.getElementById(i));
                }
            }
        }

        //helper function for BFS
        function idx(r, c) { return r * 10 + c; }

        function reveal(tile) {
            // TODO:
            // end the game if this is called on a bomb initially, otherwise it is a
            // recursive or BFS (ideally) reveal function that reveals all numbers adjacent (including diagonally)
            // to the revealed tile if it is empty (no adjacent bombs).
            // Then, reveal all other empty adjacent tiles with BFS.
            console.log(`revealing ${tile.id}`);

            // we don't need to click the button anymore, we can disable it
            tile.disabled = true;
            revealed_count++;

            // set the text on the button to the number of adjacent mines here, or if its just a mine
            if (minefield[tile.id] != 0) {
                tile.innerHTML = minefield[tile.id]
            };
            tile.style.color = number_color(minefield[tile.id]);

            if (minefield[tile.id] == 0) {
                //DFS to reveal all connected 0 cells
                let queue = [tile.id];
                while (queue.length) {
                    //removes last cell from queue 
                    let curr = queue.pop();
                    //convert current index for 1d array "minefield" into 
                    //it's corresponding row and col values
                    let r = Math.floor(curr / 10), c = curr % 10;
                    //loop through all possible directions
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            //calculate current "neighbors" row (nr) and column (nc) 
                            let nr = r + dr, nc = c + dc;
                            //convert to neighbors index (ni)
                            let ni = idx(nr, nc);
                            //get button element
                            let btn = document.getElementById(ni);
                            //check that neighbor is within the grid bounds, not already revealed, and not flagged
                            if (nr >= 0 && nr < 10 && nc >= 0 && nc < 10 && !btn.disabled && !btn.is_flagged) {
                                //update status of button
                                btn.disabled = true;
                                revealed_count++;
                                if (minefield[ni] != 0) {
                                    btn.innerHTML = minefield[ni];
                                }
                                console.log(`revealing ${ni}`);
                                btn.style.color = number_color(minefield[ni]);
                                //add current neighbor to the queue to continue to DFS 
                                //iff said current neighbor is a 0 cell
                                if (minefield[ni] === 0) queue.push(ni);
                            }
                        }
                    }
                }
            }
        }

        function generate_array(mines_amount, start_index) {
            // Generates minefield without mine in start_index
            // const minefield = new Array(100); moved to global scope, at least for now
            minefield.fill("", 0, 100 - mines_amount);
            minefield.fill("*", 100 - mines_amount, 100);
            console.log("mines: " + minefield);
            shuffle(minefield);
            console.log("start: " + minefield);
            shuffle(minefield);
            if (minefield[start_index] == "*") {
                while (minefield[start_index] == "*") {
                    shuffle(minefield);
                    console.log("iteration: " + minefield);
                }
            }
            console.log("end: " + minefield);

            // Generates "mines_nearby" values
            for (let i = 0; i < 100; i++) {
                let mines_nearby = 0;
                if (minefield[i] != "*") {
                    if (minefield[i - 11] == "*" && (i % 10 != 0)) {    // Top Left
                        mines_nearby++;
                    }
                    if (minefield[i - 10] == "*") {    // Top
                        mines_nearby++;
                    }
                    if (minefield[i - 9] == "*" && ((i + 1) % 10 != 0)) {     // Top Right
                        mines_nearby++;
                    }
                    if (minefield[i - 1] == "*" && (i % 10 != 0)) {     // Left
                        mines_nearby++;
                    }
                    if (minefield[i + 1] == "*" && ((i + 1) % 10 != 0)) {     // Right
                        mines_nearby++;
                    }
                    if (minefield[i + 9] == "*" && (i % 10 != 0)) {     // Bottom Left
                        mines_nearby++;
                    }
                    if (minefield[i + 10] == "*") {    // Bottom
                        mines_nearby++;
                    }
                    if (minefield[i + 11] == "*" && ((i + 1) % 10 != 0)) {    // Bottom Right
                        mines_nearby++;
                    }
                    minefield[i] = mines_nearby;
                }
            }
            console.log("Minefield:")
            for (let i = 0; i < 100; i += 10) {
                line = ""
                for (let j = 0; j < 10; j++) {
                    line += minefield[i + j] + " "
                }
                console.log(line)
            }

        }

        // https://javascript.info/task/shuffle
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function number_color(number) {
            // here we can assign a color based on the revealed number by checking minefield[id]. #111 was black
            if (number == 1) {
                return "blue";
            }
            else if (number == 2) {
                return "green";
            }
            else if (number == 3) {
                return "red";
            }
            else if (number == 4) {
                return "purple";
            }
            else if (number == 5) {
                return "maroon";
            }
            else if (number == 6) {
                return "teal";
            }
            else if (number == 7) {
                return "black";
            }
            else if (number == 8) {
                return "gray";
            }
            else {
                return "black";
            }
        }

    </script>
</body>

</html>